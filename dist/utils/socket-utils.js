'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

exports.bufferToArrayBuffer = bufferToArrayBuffer;
exports.arrayBufferToBuffer = arrayBufferToBuffer;
exports.encodeMessage = encodeMessage;
exports.decodeMessage = decodeMessage;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// http://updates.html5rocks.com/2012/06/How-to-convert-ArrayBuffer-to-and-from-String
function Uint16Array2str(buf) {
  return String.fromCharCode.apply(null, buf);
}

function str2Uint16Array(str) {
  var buffer = new ArrayBuffer(str.length * 2); // 2 bytes for each char
  var bufferView = new Uint16Array(buffer);

  for (var i = 0, l = str.length; i < l; i++) {
    bufferView[i] = str.charCodeAt(i);
  }
  return bufferView;
}

//http://stackoverflow.com/questions/8609289/convert-a-binary-nodejs-buffer-to-javascript-arraybuffer
// converts a nodejs Buffer to ArrayBuffer
function bufferToArrayBuffer(buffer) {
  var ab = new ArrayBuffer(buffer.length);
  var view = new Uint8Array(ab);
  for (var i = 0; i < buffer.length; ++i) {
    view[i] = buffer[i];
  }
  return ab;
}

function arrayBufferToBuffer(arrayBuffer) {
  var buffer = new Buffer(arrayBuffer.byteLength);
  var view = new Uint8Array(arrayBuffer);
  for (var i = 0; i < buffer.length; ++i) {
    buffer[i] = view[i];
  }
  return buffer;
}

// @TODO `encodeMessage` and `decodeMessage` could probably use DataView to parse the buffer

// concat the lfo stream, time and metaData into a single buffer
// the concatenation is done as follow :
//  * time          => 8 bytes
//  * frame.length  => 2 bytes
//  * frame         => 4 * frameLength bytes
//  * metaData      => rest of the message
// @return  ArrayBuffer of the created message
// @note    must create a new buffer each time because metaData length is not known
function encodeMessage(time, frame, metaData) {
  // should probably use use DataView instead
  // http://www.html5rocks.com/en/tutorials/webgl/typed_arrays/
  var time64 = new Float64Array(1);
  time64[0] = time;
  var time16 = new Uint16Array(time64.buffer);

  var length16 = new Uint16Array(1);
  length16[0] = frame.length;

  var frame16 = new Uint16Array(frame.buffer);

  var metaData16 = str2Uint16Array((0, _stringify2.default)(metaData));

  var bufferLength = time16.length + length16.length + frame16.length + metaData16.length;

  var buffer = new Uint16Array(bufferLength);

  // buffer is the concatenation of time, frameLength, frame, metaData
  buffer.set(time16, 0);
  buffer.set(length16, time16.length);
  buffer.set(frame16, time16.length + length16.length);
  buffer.set(metaData16, time16.length + length16.length + frame16.length);

  return buffer.buffer;
}

// recreate the Lfo stream (time, frame, metaData) form a buffer
// created with `encodeMessage`
function decodeMessage(buffer) {
  // time is a float64Array of size 1 (8 bytes)
  var timeArray = new Float64Array(buffer.slice(0, 8));
  var time = timeArray[0];

  // frame length is encoded in 2 bytes
  var frameLengthArray = new Uint16Array(buffer.slice(8, 10));
  var frameLength = frameLengthArray[0];

  // frame is a float32Array (4 bytes) * frameLength
  var frameByteLength = 4 * frameLength;
  var frame = new Float32Array(buffer.slice(10, 10 + frameByteLength));

  // metaData is the rest of the buffer
  var metaDataArray = new Uint16Array(buffer.slice(10 + frameByteLength));
  // JSON.parse here crashes node because of this character : `\u0000` (null in unicode) ??
  var metaData = Uint16Array2str(metaDataArray);
  metaData = JSON.parse(metaData.replace(/\u0000/g, ''));

  return { time: time, frame: frame, metaData: metaData };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNvY2tldC11dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O1FBa0JnQjtRQVNBO1FBbUJBO1FBNkJBOzs7OztBQXpFaEIsU0FBUyxlQUFULENBQXlCLEdBQXpCLEVBQThCO0FBQzVCLFNBQU8sT0FBTyxZQUFQLENBQW9CLEtBQXBCLENBQTBCLElBQTFCLEVBQWdDLEdBQWhDLENBQVAsQ0FENEI7Q0FBOUI7O0FBSUEsU0FBUyxlQUFULENBQXlCLEdBQXpCLEVBQThCO0FBQzVCLE1BQUksU0FBUyxJQUFJLFdBQUosQ0FBZ0IsSUFBSSxNQUFKLEdBQWEsQ0FBYixDQUF6QjtBQUR3QixNQUV4QixhQUFhLElBQUksV0FBSixDQUFnQixNQUFoQixDQUFiLENBRndCOztBQUk1QixPQUFLLElBQUksSUFBSSxDQUFKLEVBQU8sSUFBSSxJQUFJLE1BQUosRUFBWSxJQUFJLENBQUosRUFBTyxHQUF2QyxFQUE0QztBQUMxQyxlQUFXLENBQVgsSUFBZ0IsSUFBSSxVQUFKLENBQWUsQ0FBZixDQUFoQixDQUQwQztHQUE1QztBQUdBLFNBQU8sVUFBUCxDQVA0QjtDQUE5Qjs7OztBQVlPLFNBQVMsbUJBQVQsQ0FBNkIsTUFBN0IsRUFBcUM7QUFDMUMsTUFBSSxLQUFLLElBQUksV0FBSixDQUFnQixPQUFPLE1BQVAsQ0FBckIsQ0FEc0M7QUFFMUMsTUFBSSxPQUFPLElBQUksVUFBSixDQUFlLEVBQWYsQ0FBUCxDQUZzQztBQUcxQyxPQUFLLElBQUksSUFBSSxDQUFKLEVBQU8sSUFBSSxPQUFPLE1BQVAsRUFBZSxFQUFFLENBQUYsRUFBSztBQUN0QyxTQUFLLENBQUwsSUFBVSxPQUFPLENBQVAsQ0FBVixDQURzQztHQUF4QztBQUdBLFNBQU8sRUFBUCxDQU4wQztDQUFyQzs7QUFTQSxTQUFTLG1CQUFULENBQTZCLFdBQTdCLEVBQTBDO0FBQy9DLE1BQUksU0FBUyxJQUFJLE1BQUosQ0FBVyxZQUFZLFVBQVosQ0FBcEIsQ0FEMkM7QUFFL0MsTUFBSSxPQUFPLElBQUksVUFBSixDQUFlLFdBQWYsQ0FBUCxDQUYyQztBQUcvQyxPQUFLLElBQUksSUFBSSxDQUFKLEVBQU8sSUFBSSxPQUFPLE1BQVAsRUFBZSxFQUFFLENBQUYsRUFBSztBQUN0QyxXQUFPLENBQVAsSUFBWSxLQUFLLENBQUwsQ0FBWixDQURzQztHQUF4QztBQUdBLFNBQU8sTUFBUCxDQU4rQztDQUExQzs7Ozs7Ozs7Ozs7O0FBbUJBLFNBQVMsYUFBVCxDQUF1QixJQUF2QixFQUE2QixLQUE3QixFQUFvQyxRQUFwQyxFQUE4Qzs7O0FBR25ELE1BQUksU0FBUyxJQUFJLFlBQUosQ0FBaUIsQ0FBakIsQ0FBVCxDQUgrQztBQUluRCxTQUFPLENBQVAsSUFBWSxJQUFaLENBSm1EO0FBS25ELE1BQUksU0FBUyxJQUFJLFdBQUosQ0FBZ0IsT0FBTyxNQUFQLENBQXpCLENBTCtDOztBQU9uRCxNQUFJLFdBQVcsSUFBSSxXQUFKLENBQWdCLENBQWhCLENBQVgsQ0FQK0M7QUFRbkQsV0FBUyxDQUFULElBQWMsTUFBTSxNQUFOLENBUnFDOztBQVVuRCxNQUFJLFVBQVUsSUFBSSxXQUFKLENBQWdCLE1BQU0sTUFBTixDQUExQixDQVYrQzs7QUFZbkQsTUFBSSxhQUFhLGdCQUFnQix5QkFBZSxRQUFmLENBQWhCLENBQWIsQ0FaK0M7O0FBY25ELE1BQUksZUFBZSxPQUFPLE1BQVAsR0FBZ0IsU0FBUyxNQUFULEdBQWtCLFFBQVEsTUFBUixHQUFpQixXQUFXLE1BQVgsQ0FkbkI7O0FBZ0JuRCxNQUFJLFNBQVMsSUFBSSxXQUFKLENBQWdCLFlBQWhCLENBQVQ7OztBQWhCK0MsUUFtQm5ELENBQU8sR0FBUCxDQUFXLE1BQVgsRUFBbUIsQ0FBbkIsRUFuQm1EO0FBb0JuRCxTQUFPLEdBQVAsQ0FBVyxRQUFYLEVBQXFCLE9BQU8sTUFBUCxDQUFyQixDQXBCbUQ7QUFxQm5ELFNBQU8sR0FBUCxDQUFXLE9BQVgsRUFBb0IsT0FBTyxNQUFQLEdBQWdCLFNBQVMsTUFBVCxDQUFwQyxDQXJCbUQ7QUFzQm5ELFNBQU8sR0FBUCxDQUFXLFVBQVgsRUFBdUIsT0FBTyxNQUFQLEdBQWdCLFNBQVMsTUFBVCxHQUFrQixRQUFRLE1BQVIsQ0FBekQsQ0F0Qm1EOztBQXdCbkQsU0FBTyxPQUFPLE1BQVAsQ0F4QjRDO0NBQTlDOzs7O0FBNkJBLFNBQVMsYUFBVCxDQUF1QixNQUF2QixFQUErQjs7QUFFcEMsTUFBSSxZQUFZLElBQUksWUFBSixDQUFpQixPQUFPLEtBQVAsQ0FBYSxDQUFiLEVBQWdCLENBQWhCLENBQWpCLENBQVosQ0FGZ0M7QUFHcEMsTUFBSSxPQUFPLFVBQVUsQ0FBVixDQUFQOzs7QUFIZ0MsTUFNaEMsbUJBQW1CLElBQUksV0FBSixDQUFnQixPQUFPLEtBQVAsQ0FBYSxDQUFiLEVBQWdCLEVBQWhCLENBQWhCLENBQW5CLENBTmdDO0FBT3BDLE1BQUksY0FBYyxpQkFBaUIsQ0FBakIsQ0FBZDs7O0FBUGdDLE1BVWhDLGtCQUFrQixJQUFJLFdBQUosQ0FWYztBQVdwQyxNQUFJLFFBQVEsSUFBSSxZQUFKLENBQWlCLE9BQU8sS0FBUCxDQUFhLEVBQWIsRUFBaUIsS0FBSyxlQUFMLENBQWxDLENBQVI7OztBQVhnQyxNQWNoQyxnQkFBZ0IsSUFBSSxXQUFKLENBQWdCLE9BQU8sS0FBUCxDQUFhLEtBQUssZUFBTCxDQUE3QixDQUFoQjs7QUFkZ0MsTUFnQmhDLFdBQVcsZ0JBQWdCLGFBQWhCLENBQVgsQ0FoQmdDO0FBaUJwQyxhQUFXLEtBQUssS0FBTCxDQUFXLFNBQVMsT0FBVCxDQUFpQixTQUFqQixFQUE0QixFQUE1QixDQUFYLENBQVgsQ0FqQm9DOztBQW1CcEMsU0FBTyxFQUFFLFVBQUYsRUFBUSxZQUFSLEVBQWUsa0JBQWYsRUFBUCxDQW5Cb0M7Q0FBL0IiLCJmaWxlIjoic29ja2V0LXV0aWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vLyBodHRwOi8vdXBkYXRlcy5odG1sNXJvY2tzLmNvbS8yMDEyLzA2L0hvdy10by1jb252ZXJ0LUFycmF5QnVmZmVyLXRvLWFuZC1mcm9tLVN0cmluZ1xuZnVuY3Rpb24gVWludDE2QXJyYXkyc3RyKGJ1Zikge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBidWYpO1xufVxuXG5mdW5jdGlvbiBzdHIyVWludDE2QXJyYXkoc3RyKSB7XG4gIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoc3RyLmxlbmd0aCAqIDIpOyAvLyAyIGJ5dGVzIGZvciBlYWNoIGNoYXJcbiAgdmFyIGJ1ZmZlclZpZXcgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyKTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IHN0ci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBidWZmZXJWaWV3W2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclZpZXc7XG59XG5cbi8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NjA5Mjg5L2NvbnZlcnQtYS1iaW5hcnktbm9kZWpzLWJ1ZmZlci10by1qYXZhc2NyaXB0LWFycmF5YnVmZmVyXG4vLyBjb252ZXJ0cyBhIG5vZGVqcyBCdWZmZXIgdG8gQXJyYXlCdWZmZXJcbmV4cG9ydCBmdW5jdGlvbiBidWZmZXJUb0FycmF5QnVmZmVyKGJ1ZmZlcikge1xuICB2YXIgYWIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyLmxlbmd0aCk7XG4gIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7ICsraSkge1xuICAgIHZpZXdbaV0gPSBidWZmZXJbaV07XG4gIH1cbiAgcmV0dXJuIGFiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlCdWZmZXJUb0J1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgKytpKSB7XG4gICAgYnVmZmVyW2ldID0gdmlld1tpXTtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufVxuXG4vLyBAVE9ETyBgZW5jb2RlTWVzc2FnZWAgYW5kIGBkZWNvZGVNZXNzYWdlYCBjb3VsZCBwcm9iYWJseSB1c2UgRGF0YVZpZXcgdG8gcGFyc2UgdGhlIGJ1ZmZlclxuXG4vLyBjb25jYXQgdGhlIGxmbyBzdHJlYW0sIHRpbWUgYW5kIG1ldGFEYXRhIGludG8gYSBzaW5nbGUgYnVmZmVyXG4vLyB0aGUgY29uY2F0ZW5hdGlvbiBpcyBkb25lIGFzIGZvbGxvdyA6XG4vLyAgKiB0aW1lICAgICAgICAgID0+IDggYnl0ZXNcbi8vICAqIGZyYW1lLmxlbmd0aCAgPT4gMiBieXRlc1xuLy8gICogZnJhbWUgICAgICAgICA9PiA0ICogZnJhbWVMZW5ndGggYnl0ZXNcbi8vICAqIG1ldGFEYXRhICAgICAgPT4gcmVzdCBvZiB0aGUgbWVzc2FnZVxuLy8gQHJldHVybiAgQXJyYXlCdWZmZXIgb2YgdGhlIGNyZWF0ZWQgbWVzc2FnZVxuLy8gQG5vdGUgICAgbXVzdCBjcmVhdGUgYSBuZXcgYnVmZmVyIGVhY2ggdGltZSBiZWNhdXNlIG1ldGFEYXRhIGxlbmd0aCBpcyBub3Qga25vd25cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVNZXNzYWdlKHRpbWUsIGZyYW1lLCBtZXRhRGF0YSkge1xuICAgLy8gc2hvdWxkIHByb2JhYmx5IHVzZSB1c2UgRGF0YVZpZXcgaW5zdGVhZFxuICAvLyBodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy93ZWJnbC90eXBlZF9hcnJheXMvXG4gIHZhciB0aW1lNjQgPSBuZXcgRmxvYXQ2NEFycmF5KDEpO1xuICB0aW1lNjRbMF0gPSB0aW1lO1xuICB2YXIgdGltZTE2ID0gbmV3IFVpbnQxNkFycmF5KHRpbWU2NC5idWZmZXIpO1xuXG4gIHZhciBsZW5ndGgxNiA9IG5ldyBVaW50MTZBcnJheSgxKTtcbiAgbGVuZ3RoMTZbMF0gPSBmcmFtZS5sZW5ndGg7XG5cbiAgdmFyIGZyYW1lMTYgPSBuZXcgVWludDE2QXJyYXkoZnJhbWUuYnVmZmVyKTtcblxuICB2YXIgbWV0YURhdGExNiA9IHN0cjJVaW50MTZBcnJheShKU09OLnN0cmluZ2lmeShtZXRhRGF0YSkpO1xuXG4gIHZhciBidWZmZXJMZW5ndGggPSB0aW1lMTYubGVuZ3RoICsgbGVuZ3RoMTYubGVuZ3RoICsgZnJhbWUxNi5sZW5ndGggKyBtZXRhRGF0YTE2Lmxlbmd0aDtcblxuICB2YXIgYnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlckxlbmd0aCk7XG5cbiAgLy8gYnVmZmVyIGlzIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRpbWUsIGZyYW1lTGVuZ3RoLCBmcmFtZSwgbWV0YURhdGFcbiAgYnVmZmVyLnNldCh0aW1lMTYsIDApO1xuICBidWZmZXIuc2V0KGxlbmd0aDE2LCB0aW1lMTYubGVuZ3RoKTtcbiAgYnVmZmVyLnNldChmcmFtZTE2LCB0aW1lMTYubGVuZ3RoICsgbGVuZ3RoMTYubGVuZ3RoKTtcbiAgYnVmZmVyLnNldChtZXRhRGF0YTE2LCB0aW1lMTYubGVuZ3RoICsgbGVuZ3RoMTYubGVuZ3RoICsgZnJhbWUxNi5sZW5ndGgpO1xuXG4gIHJldHVybiBidWZmZXIuYnVmZmVyO1xufVxuXG4vLyByZWNyZWF0ZSB0aGUgTGZvIHN0cmVhbSAodGltZSwgZnJhbWUsIG1ldGFEYXRhKSBmb3JtIGEgYnVmZmVyXG4vLyBjcmVhdGVkIHdpdGggYGVuY29kZU1lc3NhZ2VgXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlTWVzc2FnZShidWZmZXIpIHtcbiAgLy8gdGltZSBpcyBhIGZsb2F0NjRBcnJheSBvZiBzaXplIDEgKDggYnl0ZXMpXG4gIHZhciB0aW1lQXJyYXkgPSBuZXcgRmxvYXQ2NEFycmF5KGJ1ZmZlci5zbGljZSgwLCA4KSk7XG4gIHZhciB0aW1lID0gdGltZUFycmF5WzBdO1xuXG4gIC8vIGZyYW1lIGxlbmd0aCBpcyBlbmNvZGVkIGluIDIgYnl0ZXNcbiAgdmFyIGZyYW1lTGVuZ3RoQXJyYXkgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyLnNsaWNlKDgsIDEwKSk7XG4gIHZhciBmcmFtZUxlbmd0aCA9IGZyYW1lTGVuZ3RoQXJyYXlbMF07XG5cbiAgLy8gZnJhbWUgaXMgYSBmbG9hdDMyQXJyYXkgKDQgYnl0ZXMpICogZnJhbWVMZW5ndGhcbiAgdmFyIGZyYW1lQnl0ZUxlbmd0aCA9IDQgKiBmcmFtZUxlbmd0aDtcbiAgdmFyIGZyYW1lID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIuc2xpY2UoMTAsIDEwICsgZnJhbWVCeXRlTGVuZ3RoKSk7XG5cbiAgLy8gbWV0YURhdGEgaXMgdGhlIHJlc3Qgb2YgdGhlIGJ1ZmZlclxuICB2YXIgbWV0YURhdGFBcnJheSA9IG5ldyBVaW50MTZBcnJheShidWZmZXIuc2xpY2UoMTAgKyBmcmFtZUJ5dGVMZW5ndGgpKTtcbiAgLy8gSlNPTi5wYXJzZSBoZXJlIGNyYXNoZXMgbm9kZSBiZWNhdXNlIG9mIHRoaXMgY2hhcmFjdGVyIDogYFxcdTAwMDBgIChudWxsIGluIHVuaWNvZGUpID8/XG4gIHZhciBtZXRhRGF0YSA9IFVpbnQxNkFycmF5MnN0cihtZXRhRGF0YUFycmF5KTtcbiAgbWV0YURhdGEgPSBKU09OLnBhcnNlKG1ldGFEYXRhLnJlcGxhY2UoL1xcdTAwMDAvZywgJycpKTtcblxuICByZXR1cm4geyB0aW1lLCBmcmFtZSwgbWV0YURhdGEgfTtcbn1cblxuIl19